


## 1. 什么是HTTP? HTTP 和 HTTPS 的区别
:::tip HTTP
  - `HTTP` (`HyperText Transfer Protocol`)，即超文本运输协议，是实现网络通信的一种规范
  ![pic](/http1.png "notice")
  - 在计算机和网络世界有，存在不同的协议，如广播协议、寻址协议、路由协议等等...
  - 而 `HTTP`是一个传输协议，即将数据由A传到B或将B传输到A，并且 `A` 与 `B`之间能够存放很多第三方，如：`A<=>X<=>Y<=>Z<=>B`
  - 传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如`HTML`文件, 图片文件, 查询结果等超文本，能够被上层应用识别
  - 在实际应用中`HTTP`常被用于在`Web`浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密
  - 特点:
    - 支持客户/服务器模式
    - 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于`HTTP`协议简单，使得`HTTP`服务器的程序规模小，因而通信速度很快
    - 灵活`HTTP`允许传输任意类型的数据对象。正在传输的类型由`Content-Type`加以标记
    - 无连接：无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接采用这种方式可以节省传输时间
    - 无状态`HTTP`协议无法根据之前的状态进行本次的请求处理
:::
:::tip HTTPS
  - `HTTP`传递信息是以明文的形式发送内容，这并不安全。而`HTTPS`出现正是为了解决 `HTTP` 不安全的特性
  - 为了保证这些隐私数据能加密传输，让HTTP运行安全的SSL/TLS协议上，即`HTTPS`=`HTTP`+`SSL/TLS`，通过`SSL`证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密
  - `SSL`协议位于`TCP/IP` 协议与各种应用层协议之间，浏览器和服务器在使用`SSL`建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持
  - 流程：
    - 首先客户端通过`URL`访问服务器建立`SSL`连接
    - 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端
    - 客户端的服务器开始协商`SSL`连接的安全等级，也就是信息加密的等级
    - 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站
    - 服务器利用自己的私钥解密出会话密钥
    - 服务器利用会话密钥加密与客户端之间的通信
:::
:::tip 区别
  - `HTTPS`是`HTTP`协议的安全版本，`HTTP`协议的数据传输是明文的，是不安全的，`HTTPS`使用了`SSL/TLS`协议进行了加密处理，相对更安全
  - `HTTP`和`HTTPS` 使用连接方式不同，默认端口也不一样，`HTTP`是`80`，`HTTPS`是`443`
  - `HTTPS`由于需要设计加密以及多次握手，性能方面不如`HTTP`
  - `HTTPS`需要`SSL`，`SSL`证书需要钱，功能越强大的证书费用越高
:::

## 2. 如何理解OSI七层模型?
:::tip OSI七层模型
  - `OSI`（`Open System Interconnect`）模型全称为开放式通信系统互连参考模型，是国际标准化组织 (`ISO`) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架
  - `OSI`将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰
  :::tip OSI七层模型
  ![pic](/iso2.png "notice")
  :::
  
  :::tip 应用层
  - 应用层位于`OSI`参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用
  - 该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的`HTTP`协议，电子邮件系统采用的`SMTP`协议等
  - 在应用层交互的数据单元我们称之为报文
  :::
  :::tip 表示层
  - 表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于`OSI`参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务
  - 该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异
  :::
  
  :::tip 会话层
  - 会话层就是负责建立、管理和终止表示层实体之间的通信会话
  - 该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法
  :::
  :::tip 传输层
  - 传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题
  - 传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层
  - 其中，主要的传输层协议是`TCP`和`UDP`
  :::
  :::tip 网络层
  - 两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网
  - 网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送
  - 在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层
  - 在网络层使用的协议是无连接的网际协议（`Internet Protocol`）和许多路由协议，因此我们通常把该层简单地称为 IP 层
  :::
  :::tip 数据链路层
  - 数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议
  - 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的`IP`数据报组装成帧，在两个相邻节点间的链路上传送帧
  - 每一帧的数据可以分成：报头`head`和数据`data`两部分:
    - `head`标明数据发送者、接受者、数据类型，如`MAC`地址
    - `data`存储了计算机之间交互的数据
  - 通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源
  :::
  :::tip 物理层
  - 作为`OSI`参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送
  - 该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）
  - 该层主要是和硬件有关，与软件关系不大
  :::

## 3.  如何理解TCP/IP协议?
:::tip TCP / IP
  - 传输控制协议/网际协议，是指能够在多个不同网络间实现信息传输的协议簇
    - `TCP`（传输控制协议）：一种面向连接的、可靠的、基于字节流的传输层通信协议
    - `IP`（网际协议）：用于封包交换数据网络的协议
  - `TCP/IP`协议不仅仅指的是`TCP`和`IP`两个协议，而是指一个由`FTP`、`SMTP`、`TCP`、`UDP`、`IP`等协议构成的协议簇
:::
:::tip 划分
  - `TCP/IP`协议族按层次分别了五层体系或者四层体系
  - 五层体系的协议结构是综合了`OSI`和`TCP/IP`优点的一种协议
    :::warning 五层体系结构
    - 应用层
    - 传输层
    - 网络层
    - 数据链路层
    - 物理层
    :::
  - 五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是`TCP/IP`四层体系结构
    :::danger 四层体系结构
    - 应用层
    - 传输层
    - 网络层
    - 数据链路层
    :::
    :::danger `TCP/IP`四层模型 
    ![pic](/iso1.webp "notice")
    :::
:::
:::tip OSI 参考模型与TCP/IP参考模型区别
  - 相同点：
    - `OSI`参考模型与`TCP/IP`参考模型都采用了层次结构
    - 都能够提供面向连接和无连接两种通信服务机制
  - 不同点：
    - `OSI`采用的七层模型，`TCP/IP`是四层或五层结构
    - `TCP/IP`参考模型没有对网络接口层进行细分，只是一些概念性的描述，`OSI`参考模型对服务和协议做了明确的区分
    - `OSI`参考模型虽然网络划分为七层，但实现起来较困难。`TCP/IP`参考模型作为一种简化的分层结构是可以的
    - `TCP/IP`协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成`OSI`设想中的应用程序维度的分层是无法实现的
  :::tip 三种模型对应关系
  ![pic](/iso3.png "notice")
  :::
:::

## 4. DNS协议 是什么？说说DNS 完整的查询过程?
:::tip DNS
  - `DNS`（`Domain Names System`），域名系统，是互联网一项服务，是进行域名和与之相对应的`IP`地址进行转换的服务器
  - 简单来讲，DNS相当于一个翻译官，负责将域名翻译成`IP`地址
    - `IP`地址：一长串能够唯一地标记网络上的计算机的数字
    - 域名：是由一串用点分隔的名字组成的`Internet`上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识
:::
:::tip 域名
  - 域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名...
  :::tip
  ![pic](/dns2.png)
:::
:::tip 查询方式
  - 递归查询：
    - 如果`A`请求`B`，那么`B`作为请求的接收者一定要给`A`想要的答案
    :::details
    ![pic](/dns3.png)
  - 迭代查询：
    - 如果接收者`B`没有请求者`A`所需要的准确内容，接收者`B`将告诉请求者`A`，如何去获得这个内容，但是自己并不去发出请求
    :::details
    ![pic](/dns4.png "notice")
:::

:::tip 域名缓存
  - 在域名服务器解析的时候，使用缓存保存域名和`IP`地址的映射，计算机中`DNS`的记录也分成了两种缓存方式：
    - 浏览器缓存：浏览器在获取网站域名的实际`IP`地址后会对其进行缓存，减少网络请求的损耗
    - 操作系统缓存：操作系统的缓存其实是用户自己配置的`hosts`文件
:::
:::tip 查询过程(解析域名的过程如下)
  - 首先搜索浏览器的`DNS`缓存，缓存中维护一张域名与`IP`地址的对应表
  - 若没有命中，则继续搜索操作系统的`DNS`缓存
  - 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的`DNS`缓存，查找成功则返回结果
  - 若本地域名服务器的`DNS`缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
    - 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
    - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
    - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的`IP`地址
  - 本地域名服务器将得到的`IP`地址返回给操作系统，同时自己将`IP`地址缓存起来
  - 操作系统将`IP`地址返回给浏览器，同时自己也将`IP`地址缓存起
  - 至此，浏览器就得到了域名对应的`IP`地址，并将`IP`地址缓存起
  :::details 流程图
  ![pic](/dns5.png "notice")
:::

## 5. 如何理解CDN？说说实现原理？
:::tip CDN
  - `CDN`(全称`Content Delivery Network`)，即内容分发网络
  - 构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。`CDN`的关键技术主要有内容存储和分发技术
  - 简单来讲，`CDN`就是根据用户位置分配最近的资源
  - 于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个`CDN`节点，术语叫边缘节点，其实就是缓存了源站内容的代理服务器
  :::tip
  ![pic](/cdn1.png)
:::
:::tip 原理分析
  - 没有应用`CDN`时：
    - 我们使用域名访问某一个站点时的路径为：
      - 用户提交域名`→`浏览器对域名进行解析→`DNS`解析得到目的主机的`IP`地址`→`根据`IP`地址访问发出请求`→`得到请求数据并回复
  - 应用`CDN`后：
    - `DNS`返回的不再是`IP`地址，而是一个`CNAME`(`Canonical Name`) 别名记录，指向`CDN`的全局负载均衡
    - `CNAME`实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是`CDN`实现的关键
:::
:::tip 负载均衡系统
  - 由于没有返回IP地址，于是本地DNS会向负载均衡系统再发送请求 ，则进入到CDN的全局负载均衡系统进行智能调度
    - 看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点
    - 看用户所在的运营商网络，找相同网络的边缘节点
    - 检查边缘节点的负载情况，找负载较轻的节点
    - 其他，比如节点的“健康状况”、服务能力、带宽、响应时间等
  - 结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问CDN的缓存代理
  :::tip 流程图：
  ![pic](/cdn2.png "notice")
:::
:::tip 缓存代理
  - 缓存系统是`CDN`的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源，其中有两个衡量`CDN`服务质量的指标：
    - 命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比 
    - 回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比
  - 缓存系统也可以划分出层次，分成一级缓存节点和二级缓存节点。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户
  - 回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源
  - 现在的商业`CDN`命中率都在`90%`以上，相当于把源站的服务能力放大了`10`倍以上
:::
:::tip 总结
  - `CDN`目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度
  - `CDN`构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速
  - 通过`CDN`的负载均衡系统，智能调度边缘节点提供服务，相当于`CDN`服务的大脑，而缓存系统相当于`CDN`的心脏，缓存命中直接返回给用户，否则回源
:::

## 6. 说说 HTTP1.0/1.1/2.0 的区别?
:::tip HTTP1.0
  - `HTTP`协议的第二个版本，第一个在通讯中指定版本号的`HTTP`协议版本
  - `HTTP1.0`浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个`TCP`连接
  - 服务器完成请求处理后立即断开`TCP`连接，服务器不跟踪每个客户也不记录过去的请求
  - 简单来讲，每次与服务器交互，都需要新开一个连接
:::tip 存在问题
  - 解析`html`文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接
  - 最终导致，一个`html`文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接这种形式明显造成了性能上的缺陷
  - 如果需要建立长连接，需要设置一个非标准的`Connection`字段 `Connection: keep-alive`
  :::tip
  ![pic](/http2.png "notice")
  :::

:::tip HTTP1.1
  - 在`HTTP1.1`中，默认支持长连接（`Connection: keep-alive`），即在一个`TCP`连接上可以传送多个`HTTP`请求和响应，减少了建立和关闭连接的消耗和延迟
  - 建立一次连接，多次请求均由这个连接完成，这样在加载`html`文件的时候，文件中多个请求和响应就可以在一个连接中传输
  - 同时，`HTTP 1.1`还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间
  - 同时，`HTTP1.1`在`HTTP1.0`的基础上，增加更多的请求头和响应头来完善的功能，如下：
    - 引入了更多的缓存控制策略，如`If-Unmodified-Since`, `If-Match`, `If-None-Match`等缓存头来控制缓存策略
    - 引入`range`，允许值请求资源某个部分
    - 引入`host`，实现了在一台`WEB`服务器上可以在同一个`IP`地址和端口号上使用不同的主机名来创建多个虚拟`WEB`站点
  - 并且还添加了其他的请求方法：
    - `put`
    - `delete`
    - `options`
    - ...
  :::tip
  ![pic](/http3.png "notice")
:::

:::tip HTTP2.0
  - 而`HTTP2.0`在相比之前版本，性能上有很大的提升，如添加了一个特性：
    - 多路复用
    - 二进制分帧
    - 首部压缩
    - 服务器推送
:::
:::tip 多路复用
  - `HTTP/2`复用`TCP`连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”
  - 下图中，可以看到第四步中`css`、`js`资源是同时发送到服务端
  :::details 
  ![pic](/http4.png "notice")
:::
:::tip 二进制分帧
  - 帧是`HTTP2`通信中最小单位信息
  - `HTTP/2`采用二进制格式传输数据，而非 `HTTP 1.x`的文本格式，解析起来更高效
  - 将请求和响应数据分割为更小的帧，并且它们采用二进制编码
  - `HTTP2`中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流
  - 每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件
:::
:::tip 首部压缩
  - `HTTP/2`在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送
  - 首部表在`HTTP/2`的连接存续期内始终存在，由客户端和服务器共同渐进地更新
  - 下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销
  :::details
  ![pic](/http5.png "notice")
:::

:::tip 服务器推送
  - `HTTP2`引入服务器推送，允许服务端推送资源给客户端
  - 服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源
  - 免得客户端再次创建连接发送请求到服务器端获取，合适加载静态资源
  :::details
  ![pic](/http6.png "notice")
:::

:::danger 总结
  - `HTTP1.0`：
    - 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个`TCP`连接
  - `HTTP1.1`：
    - 引入了持久连接，即`TCP`连接默认不关闭，可以被多个请求复用
    - 在同一个`TCP`连接里面，客户端可以同时发送多个请求
    - 虽然允许复用`TCP`连接，但是同一个`TCP`连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
    - 新增了一些请求方法
    - 新增了一些请求头和响应头
  - `HTTP2.0`：
    - 采用二进制格式而非文本格式
    - 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
    - 使用报头压缩，降低开销
    - 服务器推送
:::

## 7. 说一下 GET 和 POST 的区别？
:::tip 定义
  - `GET`方法请求一个指定资源的表示形式，使用`GET`的请求应该只被用于获取数据
  - `POST`方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用
  - 本质上都是`TCP`链接，并无差别，但是由于`HTTP`的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别
:::
:::warning 区别
  - `GET`在浏览器回退时是无害的，而`POST`会再次提交请求。
  - `GET`产生的`URL`地址可以被`Bookmark`，而`POST`不可以。
  - `GET`请求会被浏览器主动cache，而`POST`不会，除非手动设置。
  - `GET`请求只能进行`url`编码，而`POST`支持多种编码方式。
  - `GET`请求参数会被完整保留在浏览器历史记录里，而`POST`中的参数不会被保留。
  - `GET`请求在`URL`中传送的参数是有长度限制的，而`POST`没有。
  - 对参数的数据类型，`GET`只接受`ASCII`字符，而`POST`没有限制。
  - `GET`比`POST`更不安全，因为参数直接暴露在`URL`上，所以不能用来传递敏感信息。
  - `GET`参数通过`URL`传递，`POST`放在`Request body`中
:::

## 8. 说说 HTTP 常见的请求头有哪些? 作用？
:::tip HTTP请求头
  - `HTTP`头字段（`HTTP header fields`）,是指在超文本传输协议（`HTTP`）的请求和响应消息中的消息头部分
  - 它们定义了一个超文本传输协议事务中的操作参数
  - `HTTP`头部字段可以自己根据需要定义，因此可能在`Web`服务器和浏览器上发现非标准的头字段
  ```js
  // 下面是一个HTTP请求的请求头：
  :authority: sponsors.vuejs.org
  :method: GET
  :path: /data.json
  :scheme: https
  accept-encoding: gzip, deflate, br
  accept-language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7
  cache-control: no-cache
  origin: https://cn.vuejs.org
  referer: https://cn.vuejs.org/
  user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36
  accept: */*
  ```
:::
:::details  常见的请求字段：
| 字段名            |                                                                                     说明                                                                                      |                                                                             示例 |
| ----------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | -------------------------------------------------------------------------------: |
| Accept            |                                                                    能够接受的回应内容类型（Content-Types）                                                                    |                                                               Accept: text/plain |
| Accept-Charset    |                                                                               能够接受的字符集                                                                                |                                                            Accept-Charset: utf-8 |
| Accept-Encoding   |                                                                            能够接受的编码方式列表                                                                             |                                                   Accept-Encoding: gzip, deflate |
| Accept-Language   |                                                                       能够接受的回应内容的自然语言列表                                                                        |                                                           Accept-Language: en-US |
| Authorization     |                                                                      用于超文本传输协议的认证的认证信息                                                                       |                                Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== |
| Cache-Control     |                                                         用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令                                                         |                                                          Cache-Control: no-cache |
| Connection        |                                                                        该浏览器想要优先使用的连接类型                                                                         |                                       Connection: keep-alive Connection: Upgrade |
| Cookie            |                                                      服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie                                                       |                                                    Cookie: $Version=1; Skin=new; |
| Content-Length    |                                                                以 八位字节数组 （8位的字节）表示的请求体的长度                                                                |                                                              Content-Length: 348 |
| Content-Type      |                                                                              请求体的 多媒体类型                                                                              |                                  Content-Type: application/x-www-form-urlencoded |
| Date              |                                                                            发送该消息的日期和时间                                                                             |                                              Date: Tue, 15 Nov 1994 08:12:31 GMT |
| Expect            |                                                                      表明客户端要求服务器做出特定的行为                                                                       |                                                             Expect: 100-continue |
| Host              |                                                       服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号                                                       |                                 Host: en.wikipedia.org:80 Host: en.wikipedia.org |
| If-Match          | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源 |                                     If-Match: "737060cd8c284d8af7ad3082f209582d" |
| If-Modified-Since |                                                                 允许在对应的内容未被修改的情况下返回304未修改                                                                 |                                 If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT |
| If-None-Match     |                                                                 允许在对应的内容未被修改的情况下返回304未修改                                                                 |                                If-None-Match: "737060cd8c284d8af7ad3082f209582d" |
| If-Range          |                                              如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体                                               |                                     If-Range: "737060cd8c284d8af7ad3082f209582d" |
| Range             |                                                                            仅请求某个实体的一部分                                                                             |                                                             Range: bytes=500-999 |
| User-Agent        |                                                                         浏览器的浏览器身份标识字符串                                                                          | User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 |
| Origin            |                                                                      发起一个针对 跨来源资源共享 的请求                                                                       |                                                     Origin: http://www.baidu.com |
:::

:::warning 协商缓存与强缓存
  - 协商缓存是利用的是`Last-Modified`，`If-Modified-Since`和`ETag`，`If-None-Match`】这两对请求头响应头来管理的
  - `Last-Modified` 表示本地文件最后修改日期，浏览器会在`request header`加上`If-Modified-Since`（上次返回的`Last-Modified`的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来
  - `Etag`就像一个指纹，资源变化都会导致`ETag`变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的
  - `If-None-Match的header`会将上次返回的`Etag`发送给服务器，询问该资源的`Etag`是否有更新，有变动就会发送新的资源回来
  - 而强制缓存不需要发送请求到服务端，根据请求头`expires`和`cache-control`判断是否命中强缓存
  :::details 流程图如下所示
  ![pic](/cache3.png "notice")
:::

:::danger 会话状态
  - `Cookie`，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据，通过响应头`set-cookie`决定
  - 作为一段一般不超过 `4KB` 的小型文本数据，它由一个名称`Name`、一个值`Value`和其它几个用于控制`Cookie`有效期、安全性、使用范围的可选属性组成
  - `Cookie` 主要用于以下三个方面：
    - 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
    - 个性化设置（如用户自定义设置、主题等）
    - 浏览器行为跟踪（如跟踪分析用户行为等)
:::

## 9. 说说地址栏输入 URL 敲下回车后发生了什么?
:::tip 简单分析
  - 简单的分析，从输入`URL`到回车后发生的行为如下：
    - `URL`解析
    - `DNS`查询
    - `TCP`连接
    - `HTTP`请求
    - 响应请求
    - 页面渲染
:::

:::tip 详细分析
  - `URL`解析：
    - 首先判断你输入的是一个合法的`URL`还是一个待搜索的关键词，并且根据你输入的内容进行对应操作
    - `URL`的解析第过程中的第一步，一个`url`的结构解析如下：
    - ![pic](/url1.png "notice")
  - `DNS`查询
  - `TCP`连接
  - 发送`http`请求
    - 当建立`tcp`连接之后，就可以在这基础上进行通信，浏览器发送`http`请求到目标服务器
    - 请求的内容包括：
      - 请求行
      - 请求头
      - 请求主体
    - ![pic](/url2.png "notice")
  - 响应请求
    - 当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个`HTTP`响应消息，包括：
      - 状态行
      - 响应头
      - 响应正文
    - ![pic](/url3.png "notice")
    - 在服务器响应之后，由于现在`http`默认开始长连接`keep-alive`，当页面关闭之后，`tcp`链接则会经过四次挥手完成断开
  - 页面渲染
    - 当浏览器接收到服务器响应的资源后，首先会对资源进行解析：
      - 查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储`Cookie`，解压`gzip`，缓存资源等等
      - 查看响应头的`Content-Type`的值，根据不同的资源类型采用不同的解析方式
    - 关于页面的渲染过程如下：
      - 解析`HTML`，构建`DOM`树
      - 解析`CSS`，生成`CSS`规则树
      - 合并`DOM`树和`CSS`规则，生成`render`树
      - 布局render树`Layout/reflow` ，负责各元素尺寸、位置的计算
      - 绘制render树`paint`绘制页面像素信息
      - 浏览器会将各层的信息发送给`GPU`，`GPU`会将各层合成`composite`，显示在屏幕上
      - ![pic](/url4.png "notice")
:::

## 10. 说说TCP为什么需要三次握手和四次挥手？
:::danger 三次握手
  - 三次握手（`Three-way Handshake`）其实就是指建立一个`TCP`连接时，需要客户端和服务器总共发送`3`个包
  - 主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备
  - 过程如下：
    - 第一次握手：客户端给服务端发一个`SYN`报文，并指明客户端的初始化序列号`ISN(c)`，此时客户端处于`SYN_SENT`状态
    - 第二次握手：服务器收到客户端的`SYN`报文之后，会以自己的`SYN`报文作为应答，为了确认客户端的SYN，将客户端的`ISN+1`作为`ACK`的值，此时服务器处于`SYN_RCVD`的状态
    - 第三次握手：客户端收到`SYN`报文之后，会发送一个`ACK`报文，值为服务器的`ISN+1`。此时客户端处于`ESTABLISHED`状态。服务器收到`ACK`报文之后，也处于`ESTABLISHED`状态，此时，双方已建立起了连接
    - ![pic](/tcp1.png "notice")
  - 上述每一次握手的作用如下：
    - 第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的
    - 第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常
    - 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常
  - 通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了  
:::
:::warning 为什么不是两次握手
  - 如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到
  - 并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源
:::
:::danger 四次挥手
  - 第一次挥手：客户端发送一个`FIN`报文，报文中会指定一个序列号。此时客户端处于`FIN_WAIT1`状态，停止发送数据，等待服务端的确认
  - 第二次挥手：服务端收到`FIN`之后，会发送`ACK`报文，且把客户端的序列号值`+1`作为`ACK`报文的序列号值，表明已经收到客户端的报文了，此时服务端处于`CLOSE_WAIT`状态
  - 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给`FIN`报文，且指定一个序列号。此时服务端处于`LAST_ACK`的状态
  - 第四次挥手：客户端收到`FIN`之后，一样发送一个`ACK`报文作为应答，且把服务端的序列号值`+1`作为自己`ACK`报文的序列号值，此时客户端处于 `TIME_WAIT`状态。需要过一阵子以确保服务端收到自己的`ACK`报文之后才会进入`CLOSED`状态，服务端收到`ACK`报文之后，就处于关闭连接了，处于 `CLOSE`D状态
  - ![pic](/tcp2.png "notice")
:::
:::tip 四次挥手原因
  - 服务端在收到客户端断开连接`Fin`报文后，并不会立即关闭连接，而是先发送一个`ACK`包先告诉客户端收到关闭连接的请求
  - 只有当服务器的所有报文发送完毕之后，才发送`FIN`报文断开连接，因此需要四次挥手
:::
:::tip 总结
一个完整的三次握手四次挥手如下图所示：
  ![pic](/tcp3.png "notice")
:::
