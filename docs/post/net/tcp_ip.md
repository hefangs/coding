# TCP/IP协议
## TCP/IP
:::info
- 传输控制协议/网际协议，是指能够在多个不同网络间实现信息传输的协议簇
  - `TCP`（传输控制协议）：一种面向连接的、可靠的、基于字节流的传输层通信协议
  - `IP`（网际协议）：用于封包交换数据网络的协议
- `TCP/IP`协议不仅仅指的是`TCP`和`IP`两个协议，而是指一个由`FTP`、`SMTP`、`TCP`、`UDP`、`IP`等协议构成的协议簇
:::

## 五层体系结构
:::info 五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议
- 应用层
- 传输层
- 网络层
- 数据链路层
- 物理层
:::

## 四层体系结构
:::info 实际应用还是 TCP/IP 四层体系结构
- 应用层
- 传输层
- 网络层
- 数据链路层
:::

:::details
![pic](/iso1.png "notice")
:::


## OSI 参考模型与 TCP/IP 参考模型的区别
:::info 
- 相同点：
  - `OSI`参考模型与`TCP/IP`参考模型都采用了层次结构
  - 都能够提供面向连接和无连接两种通信服务机制
- 不同点：
  - `OSI`采用的七层模型，`TCP/IP`是四层或五层结构
  - `TCP/IP`参考模型没有对网络接口层进行细分，只是一些概念性的描述，`OSI`参考模型对服务和协议做了明确的区分
  - `OSI`参考模型虽然网络划分为七层，但实现起来较困难。`TCP/IP`参考模型作为一种简化的分层结构是可以的
  - `TCP/IP`协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成`OSI`设想中的应用程序维度的分层是无法实现的
- 三种模型对应关系
:::details
![pic](/iso3.png "notice")
:::


## 三次握手
:::info 
- 三次握手（`Three-way Handshake`）其实就是指建立一个`TCP`连接时，需要客户端和服务器总共发送`3`个包
- 主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备
- 过程如下：
  - 第一次握手：客户端给服务端发一个`SYN`报文，并指明客户端的初始化序列号`ISN(c)`，此时客户端处于`SYN_SENT`状态
  - 第二次握手：服务器收到客户端的`SYN`报文之后，会以自己的`SYN`报文作为应答，为了确认客户端的SYN，将客户端的`ISN+1`作为`ACK`的值，此时服务器处于`SYN_RCVD`的状态
  - 第三次握手：客户端收到`SYN`报文之后，会发送一个`ACK`报文，值为服务器的`ISN+1`。此时客户端处于`ESTABLISHED`状态。服务器收到`ACK`报文之后，也处于`ESTABLISHED`状态，此时，双方已建立起了连接
  :::details
  ![pic](/tcp1.png "notice")
- 上述每一次握手的作用如下：
  - 第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的
  - 第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常
  - 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常
- 通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了  
:::


## 三次握手原因
:::info 
- 如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到
- 并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源
:::

## 四次挥手
:::info 
- 第一次挥手：客户端发送一个`FIN`报文，报文中会指定一个序列号。此时客户端处于`FIN_WAIT1`状态，停止发送数据，等待服务端的确认
- 第二次挥手：服务端收到`FIN`之后，会发送`ACK`报文，且把客户端的序列号值`+1`作为`ACK`报文的序列号值，表明已经收到客户端的报文了，此时服务端处于`CLOSE_WAIT`状态
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给`FIN`报文，且指定一个序列号。此时服务端处于`LAST_ACK`的状态
- 第四次挥手：客户端收到`FIN`之后，一样发送一个`ACK`报文作为应答，且把服务端的序列号值`+1`作为自己`ACK`报文的序列号值，此时客户端处于 `TIME_WAIT`状态。需要过一阵子以确保服务端收到自己的`ACK`报文之后才会进入`CLOSED`状态，服务端收到`ACK`报文之后，就处于关闭连接了，处于 `CLOSE`D状态
:::details
![pic](/tcp2.png "notice")
:::

## 四次挥手原因
:::info 
- 服务端在收到客户端断开连接`Fin`报文后，并不会立即关闭连接，而是先发送一个`ACK`包先告诉客户端收到关闭连接的请求
- 只有当服务器的所有报文发送完毕之后，才发送`FIN`报文断开连接，因此需要四次挥手
:::

## 总结
:::info 
一个完整的三次握手四次挥手如下图所示：
:::details
![pic](/tcp3.png "notice")
:::