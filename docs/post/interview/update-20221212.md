

# Interview



## BFC
1.定义:
  - 块级格式化上下文
  - 是一个独立的渲染区域，让处于`BFC`内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响

2.触发条件：
  - 根元素
  - `position`: `absolute`/`fixed`
  - `display`: `inline-block` /`table`
  - `float`元素
  - `overflow` !== `visible`

3.规则：
  - 属于同一个`BFC`的两个相邻`Box`垂直排列
  - 属于同一个`BFC`的两个相邻`Box`的`margin`会发生重叠
  - `BFC`中子元素的左边 `margin`，与包含块 (`BFC`) `border` `box`的左边相接触
  - `BFC`的区域不会与 `float` 的元素区域重叠
  - 计算 `BFC` 的高度时，浮动子元素也参与计算

## 布局
### 实现两栏布局（左侧固定 + 右侧自适应布局）
```html
<div class="outer">
  <div class="left">左侧</div>
  <div class="right">右侧</div>
</div>
```
1. 利用浮动，左边元素宽度固定，设置向左浮动。将右边元素的 `margin-left` 设为固定宽度 。注意，因为右边元素的 `width` 默认为 `auto`，所以会自动撑满父元素
```css
.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  margin-left: 200px;
  /* width:auto; */
  height: 100%;
  background: lightseagreen;
}
```
2. 同样利用浮动，左边元素宽度固定，设置向左浮动。右侧元素设置`overflow`:`hidden`; 这样右边就触发了`BFC` ，`BFC`的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠
```css
.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  overflow: auto;
  height: 100%;
  background: lightseagreen;
}
```
3. 利用`flex`布局，左边元素固定宽度，右边的元素设置`flex`: 1 
```css
.outer {
  height: 100px;
  display:flex;
}
.left {
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  flex:1;
  height: 100%;
  background: lightseagreen;
}
```
4. 利用绝对定位，父级元素设为相对定位。左边元素`absolute`定位，宽度固定。右边元素的`margin-left`的值设为左边元素的宽度值
```css
.outer {
  position: relative;
  height: 100px;
}
.left {
  position: absolute;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  margin-left: 200px;
  height: 100%;
  background: lightseagreen;
}
```
5. 利用绝对定位，父级元素设为相对定位。左边元素宽度固定，右边元素`absolute`定位，`left`为宽度大小，其余方向定位为0
```css
.outer {
  position: relative;
  height: 100px;
}
.left {
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  position: absolute;
  left: 200px;
  top: 0;
  right: 0;
  bottom: 0;
  height: 100%;
  background: lightseagreen;
}
```
### 实现三栏布局（圣杯布局和双飞翼布局）
- 三栏布局，中间一栏最先加载和渲染 
- 两侧内容固定，中间内容随着宽度自适应
- 一般用于`PC`网页

1. 圣杯布局

```html
<div id="container" class="clearfix">
  <div class="center">我是中间</div>
  <div class="left">我是左边</div>
  <div class="right">我是右边</div>
</div>
```
```css
#container {
  padding-left: 200px;
  padding-right: 150px;
  overflow: auto;
}
#container div {
  float: left;
}
.center {
  width: 100%;
  background-color: lightcoral;
}
.left {
  width: 200px;
  position: relative;
  left: -200px;
  margin-left: -100%;
  background-color: lightcyan;
}
.right {
  width: 150px;
  margin-right: -150px;
  background-color: lightgreen;
}
.clearfix:after {
  content: "";
  display: table;
  clear: both;
}
```
2. 双飞翼布局
```html
<div id="main" class="float">
  <div id="main-wrap">main</div>
</div>
<div id="left" class="float">left</div>
<div id="right" class="float">right</div>
```
```css
.float {
  float: left;
}
#main {
  width: 100%;
  height: 200px;
  background-color: lightpink;
}
#main-wrap {
  margin: 0 190px 0 190px;
}
#left {
  width: 190px;
  height: 200px;
  background-color: lightsalmon;
  margin-left: -100%;
}
#right {
  width: 190px;
  height: 200px;
  background-color: lightskyblue;
  margin-left: -190px;
}
```
3. 总结：
- 使用`float`布局。
- 两侧使用`margin`负值，以便和中间内容横向重叠。
- 防止中间内容被两侧覆盖，圣杯布局用`padding`，双飞翼布局用`margin` 

### 水平垂直居中
1. 利用绝对定位，设置`left`: 50%和`top`:50%,现将子元素左上角移到父元素中心位置，然后再通过`translate`来调整子元素的中心点到父元素的中心。(该方法可以不定宽高)
```css
.father {
  position: relative;
}
.son {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}
```
2. 利用绝对定位，子元素所有方向都为0，将`margin`设置为`auto`，由于宽高固定，对应方向实现平分。(该方法必须定宽高)
```css
.father {
  position: relative;
}
.son {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0px;
  margin: auto;
  height: 100px;
  width: 100px;
}
```
3. 利用绝对定位，设置`left`:50%和`top`:50%现将子元素左上角移到父元素中心位置，然后再通过`margin-left`和`margin-top`以子元素自己的一半宽高进行负值赋值。(该方法必须定宽高)
```css
.father {
  position: relative;
}
.son {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 200px;
  height: 200px;
  margin-left: -100px;
  margin-top: -100px;
}
```
4.  利用`flex`，最经典最方便的一种了，不用解释，定不定宽高无所谓的。
```css
.father {
  display: flex;
  justify-content: center;
  align-items: center;
}
```
5. 利用`grid`(该方法必须定宽高)
```css
.father {
  width: 200px;
  height: 200px;
  border: 1px solid red;
  display: grid;
}
.son {
  width: 100px;
  height: 100px;
  background: yellow;
  margin: auto;
}
```
## 数据类型
1.  基本的数据类型介绍，及值类型和引用类型的理解
  在JS中共有8种基础的数据类型，分别为：`Undefined`、`Null`、`Boolean`、`Number`、`String`、`Object`、`Symbol`、`BigInt`
  其中`Symbol`和`BigInt`是`ES6`新增的数据类型:
      - `Symbol` 代表独一无二的值，最大的用法是用来定义对象的唯一属性名
      - `BigInt` 可以表示任意大小的整数
```js
let a = 100;
let b = a;
a = 200;
console.log(b); // 100
```
```js
let a = { age: 20 };
let b = a;
b.age = 30;
console.log(a.age); // 30
```
2. 数据类型的判断
   
  1)`typeof`：能判断所有值类型，函数。不可对`null`、对象、数组进行精确判断，因为都返回`object`
```js
console.log(typeof undefined); // undefined
console.log(typeof 2); // number
console.log(typeof true); // boolean
console.log(typeof "str"); // string
console.log(typeof Symbol("foo")); // symbol
console.log(typeof 2172141653n); // bigint
console.log(typeof function () {}); // function
// 不能判别
console.log(typeof []); // object
console.log(typeof {}); // object
console.log(typeof null); // object
```
  2)`instanceof`：能判断对象类型，不能判断基本数据类型，其内部运行机制是判断在其原型链中能否找到该类型的原型
  ```js
class People {}
class Student extends People {}
const vortesnail = new Student();
console.log(vortesnail instanceof People); // true
console.log(vortesnail instanceof Student); // true
```
  3)`Object.prototype.toString.call`()：所有原始数据类型都是能判断的，还有`Error`对象`Date`对象等
  ```js
Object.prototype.toString.call(2); // "[object Number]"
Object.prototype.toString.call(""); // "[object String]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(Math); // "[object Math]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(function () {}); // "[object Function]"
```
  4)如何判断变量是否为数组？
```js
Array.isArray(arr); // true
arr.__proto__ === Array.prototype; // true
arr instanceof Array; // true
Object.prototype.toString.call(arr); // "[object Array]"
```